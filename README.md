## 마이크로 서비스 이점 
- 기술적 자유 
- 재사용 가능한 코드 
- 복원성

## 마이크로 서비스를 위한 조건 

프로젝트 규모가 작은 경우, 모놀리식 아키텍처로 사용하고 점차 발전할수록 아래 기준으로 MSA 아키 텍처로 전환하는 것이 좋다.

1. 비용 : MSA 아키텍처를 도입할 경우，모놀리식 아키텍처에 비해 비용을 얼마나 절감할 수 있는가?

2. 개발생산성: 마이크로 서비스를 요구할 만큼 시스템 복잡도가 높은가? 또는 복잡도를 지나치게 높인 마이크로 서비스가 생산성몰 저해하고 있진 않은가?

3. 운영: 개발 팀에게 개발과 운영을 동시에 할 만묻 인프라가 준비되어 있는가? 또는 개발 인력이 마이크로 서비스룹 관리할 역랑이 있는가?
(인프라가 준비되어있는가)

4. 배포: 배포를 충분히 자주 하고 있는가? MSA는 빠론 변화에 대응하기 위해 도입하는 것인데, 회사마다 배포 일이 정해져 있고，배포가 가끔 일어난다면 효율이 떨어진다.

선배님 마이크로 서비스가 좋은건 알겠는데 현실적으로 위에 조건을 고려해보면 좋겠습니다. 
무작정 MSA를 쓰는 것은 아니다. 

마이크서비스를 위한 조건

## Monolithic vs SOA vs Microservice 

모놀리틱 - 소스코드가 모드 들어가 있다.
- SOA 
많온 사람들이 마이크로 서비스를 SOA (Service-Oriented Architecture)의 또 다른 이름으로 혼동하지만, 전통적인 SOA가 더 광범위한 프레임 워크이며 다양한 것을 의미 할 수 있습니다.
둘 다 서비스를 주요 구성 요소로 사용하지만 서비스 특성 촉면에서 크게 다릅니다.
SOA 모델은 종속적인 ESB를 가지고 있습니다. SOA는 또한 명령형 프로그래밍을 강조하는 반면 마 이크로 서비스 아키텍처는 반응 형 액터 프로그래밍 스타일에 중점을 둡니다.

**서비스 지향 아키텍처에서 ESB란 무엇인가요?**
엔터프라이즈 서비스 버스(ESB)는 여러 서비스가 있는 시스템과 롱신할 때 사용할 수 있는 소프트웨 
어로서, 기술에 관계없이 서비스악 서비스 소비자 간의 롱신을 설정합니다.


ESB의 이점

ESB는 재사용 가능한 서비스 인터페이스를 통해 통신 및 변환 기능을 제공합니다. ESB는 서비스 요청을 적절한 서비스로 라우팅하는 중앙 집중식 서비스에 비유할 수 있습니다. 또한 요청을 서비스의 기본 플랫폼 및 프로그래밍 언어에 허용되는 형식으로 변환합니다.

## Monolithic architecture
소프트웨어 공학에서 모놀리식 패턴온 하나의 분할 할 수없는 단위를 나타냅니다.
모놀리식 소프트웨어의 개념은 단일 플랫폼에서 단일 프로그램으로 결합되는 응용 프로그램의 여러 구성 요소에 있습니다. 일반적으로 모놀리식 응용 프로그램은 데이터베이스, 클라이언트 측 사용자 인터페이스 및 서버 측 응용 프로그램으로 구성됩니다. 소프트웨어의 모든 부분은 통합되어 있으며 모든 기능은 한 곳에서 관리됩니다.
모놀리식 소프트웨어의 구조를 자세히 살펴보자.
모놀리식 아키텍처는 소규모 팀이 작업하기에 편하므로 많은 신생 기업이 앱을 만들 때 이 방법을 선택 합니다.
모놀리식 소프트웨어의 구성 요소는 상호 연결되고 상호 의존적이므로 소프트웨어가 자체 포함되도록 도와졸니다. 이 아키텍처는 응용 프로그램을 구축하기 위한 전롱적인 솔루션이지만 일부 개발자는 구식이라고 생각합니다. 그러나 우리는 모놀리식 아키텍처가 어떤 상황에서는 완벽한 솔루션이라고 생각합니다.


## SOA(sersvice-oriented architecture)

MSA와 SOA는 유사한 개념 때문에 혼동하기 쉽습니다. 다만 둘의 근본적인 차이점은 범위입니다. 
SOA는 전사적인 아키텍처 접근 방식이며, MSA는 어플리케이션 개발 팀 내의 구현 전략입니다.
또한 각각의 구성 요소와 롱신하는 방법에서 차이가 있습니다. SOA는 ESB를 사용하는 반면에 마이크로서비스끼리는 언어의 제약이 없는 API를 롱해 stateless 방식으로 롱신합니다. 마이크로서비스의 API에는 언어의 제약이 없기 때문에 개발팀에서 사용하고 싶온 툴을 선택할 수 있습니다. 따라서, 
마이크로서비스의 내결합성과 유연성이 더 유연합니다.
서비스 지향 아키텍처(SOA)는 서비스라는 소프트웨어 구성 요소를 사용해 비즈니스 애둘리케이션을 
생성하는 소프트웨어 개발 방식입니다. 각 서비스는 비즈니스 기능을 제공하며, 툴랫풍과 언어롤 넘나 
들여 서로 룡신할 수 있습니다. 개발자는 SOA를 사용해 서로 다른 시스템 내의 서비스를 재사용하거 
나 독립적인 여러 서비스를 결합하여 복잡한 태스크를 수행합니다.
예를 돌어 조직 내의 여러 비즈니스 프로세스에서 사용자 인증 기능이 필요할 경우, 모든 비즈니스 프 
로세스에 대해 인증 코드를 재작성하는 대신에 단일 인증 서비스를 생성해서 모든 애콜리케이션에 재 
사용할수 있습니다. 마찬가지로, 어떤 의료 기관 내에 있는 환자관리 시스템 및 전자 건강 기록(EHR) 
시스템과 같온 거의 모든 시스템에서 환자를 등록해야 하는 경우 해당 시스템돌이 하나의 공롱 서비스 
를 호출하여 환자 등록 태스크률 수형할 수 있습니다.

## 쿠팡 MSA 사례 > 2013년까지 모놀리틱 아키텍처 적용

모놀리틱 장점 - 적은 비용으로 빠르게 적용할 수 있는! 

## 쿠팡 MSA 사례 > 모놀리틱 git 저장소 구조

이 설계는 비즈니스 초기 단계에서 우리에게 효과가 있었지만 사용자 수와 데이터 양이 수년에 걸쳐 기하 급수 적으로 증가함에 따라 모놀리식 아키텍처로 인해 5 가지 중요한 문제가 발생했습니다. 

## 쿠팡 MSA 사례 > 모놀리틱 5가지 문제점 발생

1. 확장성 리스크 및 신뢰성
모놀리식 아키텍처의 일접하게 결합된 특성으로 인해한 구성 요소의 오류는 종종 다른 구성 요소로 이어지고 전체 시스템의 중단을 초래했습니다. 예를들어 Order 구성 요소에서 메모리 오류가 발생한 코드로 인해 전체 서버의 메모리 오류가 발생했습니다.사소한코드 오류나 트래픽 급증으로 인해 심각한 서버 및 서비스 장애가 발생발 수 있습니다

2. 관심사 분리 실패
Git 저장소에는 유지 보수의 편의를 위해 여러 팀에서 사용되는 공통 모듈이 수집된 쿠페 공롱 지점이 있었습니다. 그러나 우리의 엔지니어링 조직이 성장함에 따라 쿠팡 공통의 코드는 레거시 코드가되었습니다. 사용중인 코드 블록과 사용하지 않온 코드 블록을 구별하는 것이 어려워졌으며 관리 규칙이 좋지 않았습니다. 단일 메소드를 편집하려면 엔지니어가 전사적으로 전자 메일을 발송해야 했습니다.엔지니어들은 단순히 코드 블록을 복사하여 훨씬 더 크고 혼란스러운 코드베이스틀 만들었습니다.

3. 확장성 부족
모놀리식 아키텍처에서 스케일 아웃온 전체 플랫폼을 스케일 아웃합니다，
이는 전체 시스템을 확장하기 위해 추가 서버를 확보함으로써 높온 비용으로 달성될 수 있지만，이러한 확장 방법은 비용이 많이 들 뿐만 아니라 비효율적이다. 단순히 서버 인스턴스의 수를 확장한다고 해서 병목 현상을 일으키는 아키텍처의 근본적인 문제가 해결되는 것온 아니다.병목 현상의 구체적인 예는 다음 두 가지 통증 점에서 논의됩니다.

4. 효율적인 테스트를 위한 비용증가
보안상의 이유로 엔지니어는 모든 새로운 기능에 대해 단위 및 회귀 테스트를 실행합니다. 코드에 대한 크고 
작은 수정온 모두 전체 코드베이스틀 실행하여 테스트되었습니다.우리의 코드베이스와 기눙의 수가 증가함 
에 따라, 아주 작온 수정조차도 태스트 비용이 상당히 증가했다.

5. 비효율적인 서비스 배포
서비스 배포 과정에서도 같온 이유로 병목 현상이 발생했다. 이전에는 안전하고 질서 있는 배포를 위해 배포 플래그를 사용했습니다. 배포 플래그가 있는 팀만 코드베이스를 수정하고 배포할 수 있습니다. 그러나 수백 명의 엔지니어가 우리와 합류하고 매일 수십 개의 기능이 개발되고 수정됨에 따라 배포가 크게 지연되어 단일 코드 라인을 편집 한 엔지니어가 배포하기 위해 3일을 기다려야했습니다.

그래서 쿠팡은 MSA로 전환하기 시작했다. 
